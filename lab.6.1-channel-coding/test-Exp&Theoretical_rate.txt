import numpy as np
import os
from repetitioncoder import encode_repetition, decode_repetition
from calcErrorRate import calculate_error_rate  # 导入计算误码率的函数
import csv
from math import comb

def bsc_channel(input_data, error_prob):
    noise = np.random.choice([0, 1], size=len(input_data) * 8, p=[1 - error_prob, error_prob])
    noise = np.packbits(noise)
    output_data = np.bitwise_xor(input_data, noise)
    return output_data

def calculate_error_rate_Theoretical(n, p):
    Pe = 0
    for k in range(int((n + 1) / 2), n + 1):
        Pe += comb(n, k) * (p ** k) * ((1 - p) ** (n - k))
    return Pe

def test_error_rates(error_probs):
    input_path = "input_file.bin"
    encoded_path = "encoded_file.bin"
    decoded_path = "decoded_file.bin"

    # 创建1KB大小的随机输入文件
    input_data = np.random.bytes(1024)
    with open(input_path, "wb") as file:
        file.write(input_data)

    # 创建初始的解码文件，填充全零字节，大小与输入文件相同
    with open(decoded_path, "wb") as file:
        file.write(b"\x00" * 1024)



    for error_prob in error_probs:
        print(f"Testing error probability: {error_prob}")
        for code_length in [3, 5, 7]:
            print(f"Testing code length: {code_length}")

            # 对输入文件进行重复编码
            encode_repetition(code_length, input_path, encoded_path)

            # 模拟信道传输，生成经过信道后的编码文件
            encoded_data = np.fromfile(encoded_path, dtype=np.uint8)
            channel_output = bsc_channel(encoded_data, error_prob)
            write_output(encoded_path, channel_output)

            # 对经过信道后的编码文件进行解码
            decode_repetition(encoded_path, decoded_path, code_length)

            # 使用提供的函数计算实验误码率
            calculate_error_rate(input_path, decoded_path, "temp_result.csv")
            with open("temp_result.csv", 'r') as result_file:
                reader = csv.reader(result_file)
                for row in reader:
                    experimental_error_rate = float(row[2])

            # 计算理论误码率
            theoretical_error_rate = calculate_error_rate_Theoretical(code_length,error_prob)


            print(f"Experimental Error Rate: {experimental_error_rate}")
            print(f"Theoretical Error Rate: {theoretical_error_rate}")
            print()

    # 删除临时文件
    os.remove(input_path)
    os.remove(encoded_path)
    os.remove(decoded_path)
    os.remove("temp_result.csv")

def write_output(output_path, sequence):
    sequence.tofile(output_path)

if __name__ == "__main__":
    error_probs = [0.3, 0.5, 0.8]
    test_error_rates(error_probs)